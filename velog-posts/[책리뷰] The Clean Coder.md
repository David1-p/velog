<p>작성한 코드는 자동화한 단위테스트로 빠짐없이 다 테스트하여야 한다. 
=&gt; 테스트하기 쉽게 코드를 설계하여야 하며, 가장 좋은 방법은 테스트 코드를 먼저 작성한 다음에 그 테스트를 통과하도록 코드를 작성하는 것 이게 바로 TDD</p>
<p>소프트웨어가 유연하길 바란다면 항상 실제로 조금씩 바꿔봐야 한다. 프로개발자는 코드와 테스트에 확신이 넘치기 때문에, 시도때도 없이 코드를 바꿔도 평온하다. 
클래스 이름을 바꾸기도 하고, 메소드 이름이 길다면 메소드를 나누고, switch 문장을 다형성을 활용한 구조로 바꾸고, 상속 계층을 무너뜨려 연속된 명령어(chain-of-command)로 바꿀 수 있음. </p>
<h2 id="프로소프트웨어-개발자라면">프로소프트웨어 개발자라면?</h2>
<ul>
<li>디자인 패턴: 24가지 GOF 패턴 설명가능해야 하며, POSA패턴 실무에 적용할 수준으로 알아야 한다. </li>
<li>설계원칙: SOLID 객체 지향 원칙을 알아야 하며, 컴포넌트 개념을 충분히 이해하여야 한다. </li>
<li>방법론: XP, 스크럼, 린, 칸반, 폭포수, 구조적 분석, 구조적 설계 개념을 충분히 이해하여야 한다. </li>
<li>원칙: TDD, 객체지향설계, 구조적 프로그래밍, 지속적 통합, 짝 프로그래밍을 실천해야 한다. </li>
<li>도구: UML, 데이터 흐름도(DFD), 구조차트(Structure chart), 페트리넷(petri-net), 상태전이 다이어그램과 테이블(State Transition Diagram and Table), 흐름도(flow chart), 결정 테이블(decision table)을 어떻게 쓰는지 알아야 한다. </li>
</ul>
<h2 id="코딩시-준비된-자세">코딩시 준비된 자세</h2>
<ol>
<li><p>첫째, 코드는 반드시 동작해야 한다. 풀고자 하는 문제가 어떤 문제이며, 어떻게 풀어야 하는지 확실하게 알아야 한다. 
해결법을 나타낸 코드에 믿음이 가는지 확인해야 한다. 
해결법의 언어, 플랫폼, 현재 아키텍처, 시스템의 모든 결점까지 구석구석 지속적을 관리해야 한다. </p>
</li>
<li><p>코드는 고객이 제시한 문제를 반드시 풀어야 한다. 고객의 요구사항이 고객의 문제를 해결하는데 도움이 안된다면 고객과 협상하여 고객의 진정한 필요를 충족시켜야 한다. </p>
</li>
<li><p>코드는 기존 시스템에 잘 녹아들어야 한다. 기존 시스템의 경직성, 취약함, 불투명도를 높이면 안된다. 의존성도 잘 관리해야 한다. 코드는 SOLID 객체지향 원칙을 따라야 한다. </p>
</li>
<li><p>코드는 다른 프로그래머가 읽기 쉬워야 한다. 주석을 잘쓰라는 조언이 아니라 만든 사람의 의도가 드러나도록 코드를 잘 다듬어야 한다. 지치거나 주의력이 떨어졌으면 코드를 작성하지 말고 잠시 쉬거나, pair programming처럼 다른 사람과 함께 코드를 작성해보면 코드를 쉽게 작성할 수 있다. </p>
</li>
</ol>
<h2 id="tdd">TDD?</h2>
<p>익스트림 프로그래밍(XP) 움직임의 일부로 시작했으나 스크럼(scrum)을 포함한 사실상 모든 애자일 방법론에서 TDD를 받아들임. </p>
<p>&lt;TDD의 세가지 법칙&gt;</p>
<ol>
<li>실패한 단위 테스트를 만들기 전에는 제품 코드를 만들지 않는다. </li>
<li>컴파일이 안되거나 실패한 단위 테스트가 있으면 더 이상의 단위 테스트를 만들지 않는다. </li>
<li>실패한 단위 테스트를 통과하는 이상의 제품 코드는 만들지 않는다. </li>
</ol>
<p>이 세가지 법칙을 지키면 반복 주기는 대략 30초 길이를 유지한다. 처음에는 작은 단위 테스트를 만들며 시작한다. 하지만 몇 초 지나지 않아 아직 만들지도 않은 클래스나 함수의 이름을 써야 하고, 그 때문에 단위 테스트는 컴파일되지 않는다. 따라서 테스트가 컴파일되도록 제품코드를 만들어야 한다. 하지만 그 이상의 제품 코드를 만들면 안되기 때문에 단위 테스트를 더 만들기 시작한다. 거듭해서 주기를 반복한다. 테스트 코드를 조금 추가한다. 제품 코드도 조금 추가한다. 두 가지 코드 흐름이 동시에 자라나 상호보완하는 컴포넌트가 된다. 항체와 항원처럼 테스트와 제품 코드가 딱 들어맞는다. </p>